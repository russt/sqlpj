#
#psqlImpl.defs -  definitions for psqlImpl object.
#

#allows us to run stand-alone:
%ifndef CG_ROOT %include build_setup.defs

{ ## header section
PL_PACKAGE = $PSQLIMPL_PACKAGE
PL_PACKAGE_DESCRIPTION = perl/jdbc sql command line interpreter

#not a base class - use standard constuctor name:
PL_CONSTRUCTOR_NAME = new

PL_PKG_IMPORTS := << EOF
use JDBC;
use Inline::Java qw(caught);
EOF
#%evalmacro PL_PKG_IMPORTS PL_PKG_IMPORTS

PL_PKG_ATTRIBUTES := << EOF
my $mPROMPT = $pkgname . "> ";
EOF
#%evalmacro PL_PKG_ATTRIBUTES PL_PKG_ATTRIBUTES
}

{ ## constructor section
PL_CONSTRUCTOR_BODY := << EOF
my ($url, $driver ,$user, $password, $prompt) = @_;
EOF
#%evalmacro PL_CONSTRUCTOR_BODY PL_CONSTRUCTOR_BODY

PL_OBJ_ATTRIBUTES := << EOF
'mJdbcDriver'  => $driver,
'mJdbcUrl'     => $url,
'mUser'        => $user,
'mPassword'    => $password,
'mPrompt'      => $prompt,
'mConnection'  => undef,
EOF
#%evalmacro PL_OBJ_ATTRIBUTES PL_OBJ_ATTRIBUTES

#this is for further initialzation of attributes, since hash init cannot be self-referential:
PL_POST_ATTRIBUTE_INIT := << EOF
EOF
#%evalmacro PL_POST_ATTRIBUTE_INIT PL_POST_ATTRIBUTE_INIT
}

{ ## class methods

#clear standard accessor accumulator:
getset_methods =

#generate read/write (get/set) accessors:
PL_ATTRIBUTE_NAME = Connection
%evalmacro >> getset_methods pl_getset

#generate read-only attributes:
PL_ATTRIBUTE_NAME = JdbcUrl
%evalmacro >> getset_methods pl_attr_method
PL_ATTRIBUTE_NAME = JdbcDriver
%evalmacro >> getset_methods pl_attr_method
PL_ATTRIBUTE_NAME = User
%evalmacro >> getset_methods pl_attr_method
PL_ATTRIBUTE_NAME = Password
%evalmacro >> getset_methods pl_attr_method
PL_ATTRIBUTE_NAME = Prompt
%evalmacro >> getset_methods pl_attr_method

{
PL_PKG_METHODS := << EOF
sub sqlsession
# Parse and execute sql statements.  Grammar:
# sqlsession     -> sql_statement* '<EOF>'
# sql_statement  -> stuff ';' '<EOL>'
#             -> stuff '<EOL>' 'go' ( '<EOL>' | '<EOF>' )
#             -> stuff '<EOL>' ';' ( '<EOL>' | '<EOF>' )
#             -> stuff '<EOF>'
# Display prompts if session is interactive.
# @param aFh is the input stream containing the sql statements.
# @return false if error getting connection
{
    my ($self, $aFh, $fn) = @_;

    printf STDERR "%s[sqlsession]: reading from file '%s'\n", $pkgname, $fn;

    if (!$self->sql_init_connection()) {
        printf STDERR "%s:[sqlsession]:  cannot get a database connection:  ABORT\n", $pkgname;
        return 0;
    }

    my $sqlbuf = "";
	my $lbuf = "";

	print $self->prompt();

    while ($lbuf = <$aFh>)
	{
		#append the buffer:
		$sqlbuf .= $lbuf;

		#if it is time to execute the buffer ...
		if ($sqlbuf =~ /;[;\s]*$/) {
			#... then remove the semi-colon:
			$sqlbuf =~ s/;[;\s]*$//;

			#if the buffer has something in it, then send it to the database:
            if ($sqlbuf !~ /^\s*$/) {
                $self->sql_exec($sqlbuf);

				#display the results:
			}

			#in any case, zero the buffer:
			$sqlbuf = "";
		}

		print $self->prompt();
    }

    $self->sql_close_connection();

    return 1;
}

sub sql_exec
# Execute a single sql statement.
# @param sqlbuf is the buffer containing the input.
{
    my ($self, $sqlbuf) = @_;

#printf STDERR "sql_exec: buf='%s'\n", $sqlbuf;

	my $stmt = undef;
	my $con  = $self->getConnection();

    eval {
		$stmt = $con->createStatement();
        #mStatement = mConnection.createStatement();

        my $results = undef;
        #java.sql.ResultSet results = null;

        my $updateCount = -1;

        #if we have results...
        if ($stmt->execute($sqlbuf)) {
            $results = $stmt->getResultSet();
            $self->displayResultSet($results);
        } else {
            #no results - see if we have an update count
            $updateCount = $stmt->getUpdateCount();

            #if we have an update count...
            if ($updateCount != -1) {
				printf "update count=%d\n", $updateCount;
            }
        }
    };

	if ($@) {
		if (caught("java.sql.SQLException")){
			my $msg = $@->getMessage() ;
			printf STDERR "%s[sql_exec]:  Java exception: execute: '%s'\n", $pkgname, $msg;
		} else {
			printf STDERR "%s[sql_exec]:  ERROR on execute: '%s'\n",$pkgname, $@;
		}
		return 0;
	}

	return 1;    #success
}

sub displayResultSet
# display resultSet <rset>
{
    my ($self, $rset) = @_;

	return "(null)" unless defined($rset);

	#we first make a pass to get all the rows into memory:
	my @allrows = ();
	
	#save column headers:
	push @allrows, [&getColumns($rset)];

	#save data rows:
	while ($rset->next()) {
		push @allrows, [&getRow($rset)];
	}

	#next, we iterate through the rows to set the max column size:
	my (@sizes) = ();
	for my $rowref (@allrows) {
		&setMaxColumnSizes(\@sizes, $rowref);
	}

	#generate a format spec based on display sizes:
	my $fmt = "|";
	my $total = 0;
	for my $sz (@sizes) {
		$fmt .= "%-" . "$sz" . "s|";
		$total +=  $sz;
	}

	#create a row divider:
	my $divider =  "+" . "-" x ($#sizes + $total) . "+" . "\n";

#printf STDERR "fmt='%s' divider=\n%s\n", $fmt, $divider;

	#######
	#column headers:
	#######
	my $rowref =  shift(@allrows);
	print $divider;
	printf $fmt. "\n", @{$rowref};
	print $divider;

	#display data:
	while (defined($rowref =  shift(@allrows))) {
		printf $fmt. "\n", @{$rowref};
	}
	print $divider;

	return 1;    #success
}

# Check and initialize our jdbc driver class.
# @return true if driver is in the CLASSPATH
sub check_driver
{
    my ($self) = @_;

	#initialize our driver class:
	eval {
		JDBC->load_driver($self->jdbcDriver());
	};

	if ($@) {
		if (caught("java.lang.ClassNotFoundException")){
			my $msg = $@->getMessage() ;
			printf STDERR "%s[check_driver]:  Java exception: on JDBC->load_driver(%s): '%s'\n",$pkgname, $self->jdbcDriver(), $msg;
			#xx = Class.forName(this.mDRIVER).toString();
		} else {
			printf STDERR "%s[check_driver]:  ERROR on JDBC->load_driver(%s): '%s'\n",$pkgname, $self->jdbcDriver(), $@;
		}
		return 0;
	}

	return 1;
}

sub sql_init_connection
# open the jdbc connection.
# @return true if successful.
{
    my ($self) = @_;

	#try to get a connection:
	eval {
		$self->setConnection(JDBC->getConnection($self->jdbcUrl(), $self->user(), $self->password()));
		#mConnection = java.sql.DriverManager.getConnection(mURL, mUSER, mPASSWORD);
	};

	if ($@) {
		if (caught("java.sql.SQLException")){
			my $msg = $@->getMessage() ;
			printf STDERR "%s[sql_init_connection]:  Java exception: on connect: '%s'\n", $pkgname, $msg;
		} else {
			printf STDERR "%s[sql_init_connection]:  ERROR on connect: '%s'\n",$pkgname, $@;
		}
		return 0;
	}

    return 1;    #success
}

sub sql_close_connection
# close the jdbc connection.
# true if successful
{
    my ($self) = @_;

	return unless defined($self->getConnection());

	#close connection: #don't care if this fails
	eval {
		$self->getConnection()->close();
	};

	if ($@) {
		if (caught("java.sql.SQLException")){
			my $msg = $@->getMessage() ;
			printf STDERR "%s[sql_close_connection]:  Java exception: on connect: '%s'\n", $pkgname, $msg;
		} else {
			printf STDERR "%s[sql_close_connection]:  ERROR on connect: '%s'\n",$pkgname, $@;
		}
		return 0;
	}

    return 1;    #success
}

#######
#static class methods
#######

sub getColumns
#return the list of column names for a result set
{
    my ($rset) = @_;

	return () unless defined($rset);

	my (@header) = ();

    eval {
        my $m        = $rset->getMetaData();
        my $colcnt   = $m->getColumnCount();

		#store column headers:
        for (my $ii = 1; $ii <= $colcnt; $ii++) {
			push @header, $m->getColumnLabel($ii);
        }
    };

	if ($@) {
		if (caught("java.sql.SQLException")){
			my $msg = $@->getMessage() ;
			printf STDERR "%s[getColumns]:  Java exception: '%s'\n", $pkgname, $msg;
		} else {
			printf STDERR "%s[getColumns]:  ERROR: '%s'\n",$pkgname, $@;
		}
        return ();
	}

	return @header;
}

sub getColumnSizes
#return the list of column display sizes for a result set
{
    my ($rset) = @_;

	return () unless defined($rset);

	my (@widths) = ();

    eval {
        my $m        = $rset->getMetaData();
        my $colcnt   = $m->getColumnCount();

        for (my $ii = 1; $ii <= $colcnt; $ii++) {
			push @widths, $m->getColumnDisplaySize($ii);
        }
    };

	if ($@) {
		if (caught("java.sql.SQLException")){
			my $msg = $@->getMessage() ;
			printf STDERR "%s[getColumns]:  Java exception: '%s'\n", $pkgname, $msg;
		} else {
			printf STDERR "%s[getColumns]:  ERROR: '%s'\n",$pkgname, $@;
		}
        return ();
	}

	return @widths;
}

sub getRow
#return the list of column names for a result set
{
    my ($rset) = @_;

	return () unless defined($rset);

	my (@data) = ();

    eval {
        my $colcnt   = $rset->getMetaData()->getColumnCount();

        for (my $ii = 1; $ii <= $colcnt; $ii++) {
			push @data, ($rset->wasNull())? "(null)" : $rset->getString($ii);
		}
    };

	if ($@) {
		if (caught("java.sql.SQLException")){
			my $msg = $@->getMessage() ;
			printf STDERR "%s[getRow]:  Java exception: '%s'\n", $pkgname, $msg;
		} else {
			printf STDERR "%s[getRow]:  ERROR: '%s'\n",$pkgname, $@;
		}
        return ();
	}

	return @data;
}

sub setMaxColumnSizes
#set each element in <szref> to be max(curr, new) width for display
{
	my ($szref, $rowref) = @_;

	my @sizes = @{$szref};
	my @data =  @{$rowref};

	if ($#sizes != $#data) {
		#initialize sizes:
		@sizes = (0) x ($#data + 1);
	}

	for (my $ii = 0; $ii <= $#data; $ii++) {
		$sizes[$ii] = &maxwidth( $sizes[$ii], length(sprintf("%s", $data[$ii])) );
	}

	@{$szref} = @sizes;
}

sub maxwidth
#return the max of two numbers
{
	my ($ii, $jj) = @_;

	return (($ii >= $jj)? $ii : $jj);
}


#########
#accessor methods for {=PL_PACKAGE=} object attributes:
#########

{=getset_methods=}
EOF

%evalmacro PL_PKG_METHODS PL_PKG_METHODS
}


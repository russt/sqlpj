#
#psqlImpl.defs -  definitions for psqlImpl object.
#

#allows us to run stand-alone:
%ifndef CG_ROOT %include build_setup.defs

{ ## header section
%ifndef PL_PACKAGE       PL_PACKAGE = $PSQLIMPL_PACKAGE
PL_PACKAGE_DESCRIPTION = perl/jdbc sql command line interpreter

#not a base class - use standard constuctor name:
PL_CONSTRUCTOR_NAME = new

PL_PKG_IMPORTS := << EOF
use JDBC;
use Inline::Java qw(caught);
use {=SQLTABLES_PACKAGE=};
use {=SQLTABLE_PACKAGE=};
EOF
%evalmacro PL_PKG_IMPORTS PL_PKG_IMPORTS

PL_PKG_ATTRIBUTES := << EOF
my $mPROMPT = $pkgname . "> ";
EOF
#%evalmacro PL_PKG_ATTRIBUTES PL_PKG_ATTRIBUTES
}

{ ## constructor section
PL_CONSTRUCTOR_BODY := << EOF
my ($cfg) = @_;
EOF
#%evalmacro PL_CONSTRUCTOR_BODY PL_CONSTRUCTOR_BODY

PL_OBJ_ATTRIBUTES := << EOF
'mJdbcClassPath'  => $cfg->getJdbcClassPath(),
'mJdbcDriver'  => $cfg->getJdbcDriverClass(),
'mJdbcUrl'     => $cfg->getJdbcUrl(),
'mUser'        => $cfg->getJdbcUser(),
'mPassword'    => $cfg->getJdbcPassword(),
'mPrompt'      => $cfg->getPrompt(),
'mConnection'  => undef,
'mMetaData'    => undef,
'mMetaFuncs'    => undef,
'mDatabaseName' => undef,
'mSqlTables'    => undef,      #handle to tables object for this connection
'mXmlDisplay'   => 0,          #if true, display result-sets as sql/xml
'mPathSeparator' => $cfg->getPathSeparator(),
EOF
#%evalmacro PL_OBJ_ATTRIBUTES PL_OBJ_ATTRIBUTES

#this is for further initialzation of attributes, since hash init cannot be self-referential:
PL_POST_ATTRIBUTE_INIT := << EOF
#read in database meta-function interface definitions:
%{$self->{'mMetaFuncs'}}      = (
{=%include dbmeta.defs=}
);
EOF
%evalmacro PL_POST_ATTRIBUTE_INIT PL_POST_ATTRIBUTE_INIT
}

{ ## class methods

#clear standard accessor accumulator:
getset_methods =

#generate read/write (get/set) accessors:
PL_ATTRIBUTE_NAME = Connection
%evalmacro >> getset_methods pl_getset
PL_ATTRIBUTE_NAME = MetaData
%evalmacro >> getset_methods pl_getset
PL_ATTRIBUTE_NAME = JdbcUrl
%evalmacro >> getset_methods pl_getset
PL_ATTRIBUTE_NAME = DatabaseName
%evalmacro >> getset_methods pl_getset
PL_ATTRIBUTE_NAME = SqlTables
%evalmacro >> getset_methods pl_getset
PL_ATTRIBUTE_NAME = XmlDisplay
%evalmacro >> getset_methods pl_getset

#generate read-only attributes:
PL_ATTRIBUTE_NAME = JdbcClassPath
%evalmacro >> getset_methods pl_attr_method
PL_ATTRIBUTE_NAME = JdbcDriver
%evalmacro >> getset_methods pl_attr_method
PL_ATTRIBUTE_NAME = User
%evalmacro >> getset_methods pl_attr_method
PL_ATTRIBUTE_NAME = Password
%evalmacro >> getset_methods pl_attr_method
PL_ATTRIBUTE_NAME = PathSeparator
%evalmacro >> getset_methods pl_attr_method
PL_ATTRIBUTE_NAME = Prompt
%evalmacro >> getset_methods pl_attr_method
PL_ATTRIBUTE_NAME = MetaFuncs
%evalmacro >> getset_methods pl_attr_method

{
PL_PKG_METHODS := << EOF
sub sqlsession
# Parse and execute sql statements.  Grammar:
# sqlsession     -> sql_statement* '<EOF>'
# sql_statement  -> stuff ';' '<EOL>'
#             -> stuff '<EOL>' 'go' ( '<EOL>' | '<EOF>' )
#             -> stuff '<EOL>' ';' ( '<EOL>' | '<EOF>' )
#             -> stuff '<EOF>'
# Display prompts if session is interactive.
# @param aFh is the input stream containing the sql statements.
# @return false if error getting connection
{
    my ($self, $aFh, $fn) = @_;

#printf STDERR "%s[sqlsession]: reading from file '%s'\n", $pkgname, $fn;
#printf STDERR "%s[sqlsession]: aFh is a '%s'\n", $pkgname, ref($aFh);

    if (!$self->sql_init_connection()) {
        printf STDERR "%s:[sqlsession]:  cannot get a database connection:  ABORT\n", $pkgname;
        return 0;
    }

    my $sqlbuf = "";
    my $lbuf = "";

    print $self->prompt();

    while ($lbuf = <$aFh>)
    {
        #local commands:
        if ($self->localCommand($lbuf)) {
            print $self->prompt();
            next;
        }

        #append the buffer:
        $sqlbuf .= $lbuf;

        #if it is time to execute the buffer ...
        if ($sqlbuf =~ /;[;\s]*$/) {
            #... then remove the semi-colon:
            $sqlbuf =~ s/;[;\s]*$//;

            #if the buffer has something in it, then send it to the database:
            if ($sqlbuf !~ /^\s*$/) {
                $self->sql_exec($sqlbuf);

                #display the results:
            }

            #in any case, zero the buffer:
            $sqlbuf = "";
        }

        print $self->prompt();
    }

    $self->sql_close_connection();

    return 1;
}

sub sql_exec
# Execute a single sql statement.
# @param sqlbuf is the buffer containing the input.
{
    my ($self, $sqlbuf) = @_;

#printf STDERR "sql_exec: buf='%s'\n", $sqlbuf;

    my $stmt = undef;
    my $con  = $self->getConnection();

    eval {
        $stmt = $con->createStatement();
        #mStatement = mConnection.createStatement();

        my $results = undef;
        #java.sql.ResultSet results = null;

        my $updateCount = -1;

        #if we have results...
        if ($stmt->execute($sqlbuf)) {
            $results = $stmt->getResultSet();
            $self->displayResultSet($results, &columnExcludeMap($results, ()));
        } else {
            #no results - see if we have an update count
            $updateCount = $stmt->getUpdateCount();

            #if we have an update count...
            if ($updateCount != -1) {
                printf "update count=%d\n", $updateCount;
            }
        }
    };

    if ($@) {
        if (caught("java.sql.SQLException")){
            my $msg = $@->getMessage() ;
            printf STDERR "%s[sql_exec]:  Java exception: execute: '%s'\n", $pkgname, $msg;
        } else {
            printf STDERR "%s[sql_exec]:  ERROR on execute: '%s'\n",$pkgname, $@;
        }
        return 0;
    }

    return 1;    #success
}

sub displayXmlResults
#we get a list of lists as input.  The first row containes the column names.
#row elements may have undef values, in which case we do not display them
#(this is the "absent rows" method in the spec).
{
    my ($self, $tblname, $rows) = @_;

    $tblname = "UNKNOWN_TABLE" if ($tblname eq "");

    my $ii = 0;
    my $nrows = $#{$rows};

    my $indentlevel = 0;
    my $indentstr = " " x 2;
    my $indent = $indentstr x $indentlevel;

    printf "%s<%s>\n", $indent, $tblname;
    $indentlevel++; $indent = $indentstr x $indentlevel;

    #first row is the column names:
    my $rref = $$rows[$ii++];
    my (@headers) = @$rref;

#printf STDERR "nrows=%d headers=(%s)\n", $nrows, join(',', @headers);

    #foreach row of data:
    for ($ii = $ii; $ii <= $nrows; $ii++) {

        printf "%s<row>\n", $indent;
        $indentlevel++; $indent = $indentstr x $indentlevel;

        $rref = $$rows[$ii];
        #foreach column in the row:
        for (my $jj = 0; $jj <= $#$rref; $jj++) {
            #display the row unless it was SQL NULL:
            if (defined($$rref[$jj])) {
                printf "%s<%s>%s</%s>\n", $indent, $headers[$jj], $$rref[$jj], $headers[$jj];
            }
        }

        $indentlevel--; $indent = $indentstr x $indentlevel;
        printf "%s</row>\n", $indent;
    }

    $indentlevel--; $indent = $indentstr x $indentlevel;
    printf "%s</%s>\n", $indent, $tblname;
}

sub displayResultSet
# display resultSet <rset>
{
    my ($self, $rset, @colmap) = @_;

    return 0 unless defined($rset);

    #we first make a pass to get all the rows into memory:
    my @allrows = ();
    
    #save column headers:
    push @allrows, [&getColumns($rset, @colmap)];

    my $tableName = &getTableName($rset);

    #save data rows:
    while ($rset->next()) {
        push @allrows, [&getRow($rset, $self->getXmlDisplay(), @colmap)];
    }

    ########
    #XML/SQL if set:
    ########
    if ($self->getXmlDisplay()) {
        return $self->displayXmlResults($tableName, \@allrows);
    }

    #next, we iterate through the rows to set the max column size:
    my (@sizes) = ();
    for my $rowref (@allrows) {
        &setMaxColumnSizes(\@sizes, $rowref);
    }

    #generate a format spec based on display sizes:
    my $fmt = "|";
    my $total = 0;
    for my $sz (@sizes) {
        $fmt .= "%-" . "$sz" . "s|";
        $total +=  $sz;
    }

    #create a row divider:
    my $divider =  "+" . "-" x ($#sizes + $total) . "+" . "\n";

#printf STDERR "fmt='%s' divider=\n%s\n", $fmt, $divider;

    #######
    #column headers:
    #######
    my $rowref =  shift(@allrows);
    print $divider;
    printf $fmt. "\n", @{$rowref};
    print $divider;

    #display data:
    while (defined($rowref =  shift(@allrows))) {
        printf $fmt. "\n", @{$rowref};
    }
    print $divider;

    return 1;    #success
}

# Check and initialize our jdbc driver class.
# @return true if driver is in the CLASSPATH
sub check_driver
{
    my ($self) = @_;

    #initialize our driver class:
    eval {
        JDBC->load_driver($self->jdbcDriver());
    };

    if ($@) {
        if (caught("java.lang.ClassNotFoundException")){
            my $msg = $@->getMessage() ;
            printf STDERR "%s[check_driver]:  Java exception: on JDBC->load_driver(%s): '%s'\n",$pkgname, $self->jdbcDriver(), $msg;
            #xx = Class.forName(this.mDRIVER).toString();
        } else {
            printf STDERR "%s[check_driver]:  ERROR on JDBC->load_driver(%s): '%s'\n",$pkgname, $self->jdbcDriver(), $@;
        }
        return 0;
    }

    return 1;
}

sub sql_init_connection
# open the jdbc connection.
# return true if successful.
{
    my ($self) = @_;

    #make sure currentl connection is closed:
    $self->sql_close_connection();

    #try to get a connection:
    eval {
        $self->setConnection(JDBC->getConnection($self->getJdbcUrl(), $self->user(), $self->password()));
        #mConnection = java.sql.DriverManager.getConnection(mURL, mUSER, mPASSWORD);

        #also set a handle for DatabaseMetaData:
        $self->setMetaData( $self->getConnection()->getMetaData() );

        #set database name from connection url:
        $self->setDatabaseName( &getDbnameFromUrl($self->getJdbcUrl()) );
    };

    if ($@) {
        if (caught("java.sql.SQLException")){
            my $msg = $@->getMessage() ;
            printf STDERR "%s[sql_init_connection]:  Java exception: on connect: '%s'\n", $pkgname, $msg;
        } else {
            printf STDERR "%s[sql_init_connection]:  ERROR on connect: '%s'\n",$pkgname, $@;
        }
        return 0;
    }

    #init or re-init our tables object:
    $self->setSqlTables( new {=SQLTABLES_PACKAGE=}($self->getMetaData(), $self->getDatabaseName()) );

    return 1;    #success
}

sub sql_close_connection
# close the jdbc connection.
# true if successful
{
    my ($self) = @_;

    return unless defined($self->getConnection());

    #close connection: #don't care if this fails
    eval {
        $self->getConnection()->close();
    };

    if ($@) {
        if (caught("java.sql.SQLException")){
            my $msg = $@->getMessage() ;
            printf STDERR "%s[sql_close_connection]:  Java exception: on connect: '%s'\n", $pkgname, $msg;
        } else {
            printf STDERR "%s[sql_close_connection]:  ERROR on connect: '%s'\n",$pkgname, $@;
        }
        return 0;
    }

    return 1;    #success
}

######
#local command processing
######

sub localCommand
#process a local command:
#    help
#    info
{
    my ($self, $buf) = @_;

    #trim buf:
    $buf =~ s/^\s+//;
    $buf =~ s/[;\s]*$//;

    my $handled = 0;

    if ($buf =~ /^help/i) {
        $buf =~ s/help\s*//i;
        $handled = $self->helpCommand($buf);
    } elsif ($buf  =~ /^set/i) {
        $buf =~ s/set\s*//i;
        $handled = $self->setCommand($buf);
    } elsif ($buf  =~ /^use/i) {
        $buf =~ s/use\s*//i;
        $handled = $self->useCommand($buf);
    } elsif ($buf  =~ /^show/i) {
        $buf =~ s/show\s*//i;
        $handled = $self->showCommand($buf);
    } elsif ($buf  =~ /^tables/i) {
        $buf =~ s/tables\s*//i;
        $handled = $self->showTablesCommand($buf);
    } elsif ($buf  =~ /^table/i) {
        $buf =~ s/table\s*//i;
        $handled = $self->showTableCommand($buf);
    }

    return $handled;
}

sub helpCommand
#return 1 if we handled the command, otherwise 0.
{
    my ($self, $args) = @_;

    print <<"!";
Local commands are:
 help                 - show this message.

 set xml [on]         - output result-sets in sql/xml form.
 set xml off          - turn off xml output of result-sets.

 tables [db]          - show information about tables in <db>, defaults to connection db.
                        (similar to "show tables" in mysql).
 table name [db]      - show information about table <name> in <db>, defaults to connection db.
                        (can also use "describe <table>" in mysql & oracle).
                        (can also use "show columns from <table>" in mysql).

 show conn[ection]    - show jdbc connection properties, including product & version
 show create [table]  - generate sql to create all tables, or a single table.
 show ind[ices] table - show the indices for a single table
 show db              - show db name
 show metadata        - show jdbc metadata (long)
!

#not yet implemented:
#help [command]       - show this message, or help about specific <command>.
#dump [table] [filename]
#                     - dump all or named table to stdout or <filename>

    return 1;    #we processed the help command.
}

sub showCommand
#show meta-info about the database and/or tables
#return 1 if we handled the command, otherwise 0.
{
    my ($self, $buf) = @_;

    #trim buf:
    $buf =~ s/^\s+//;
    $buf =~ s/[;\s]*$//;

    if ($buf =~ /^conn/i) {
        $buf =~ s/conn[^\s]*\s*//i;
        $self->showConnection($buf);
    } elsif ($buf  =~ /^create/i) {
        $buf =~ s/create\s*//i;
        $self->showCreate($buf);
    } elsif ($buf  =~ /^db/i) {
        $buf =~ s/db\s*//i;
        $self->showDataBase($buf);
    } elsif ($buf  =~ /^ind/i) {
        $buf =~ s/ind[^\s]*\s*//i;
        $self->showIndicesCommand($buf);
    } elsif ($buf  =~ /^meta/i) {
        $buf =~ s/meta[^\s]*\s*//i;
        $self->showMetaData($buf);
    } else {
        return 0;    #not a local command
    }

    return 1;    #we processed the show command locally.
}

sub setCommand
#set display or other options for the cli.
#return 1 if we handled the command, otherwise 0.
{
    my ($self, $buf) = @_;

    if ($buf =~ /^xml/i) {
        $buf =~ s/xml\s*//i;
        my $howsay = "remains";
        if ($buf eq "" || $buf =~ /^on/i) {
            if (!$self->getXmlDisplay()) {
                $self->setXmlDisplay(1);
                $howsay = "is now";
            }
        } elsif ($buf =~ /^off/i) {
            if ($self->getXmlDisplay()) {
                $self->setXmlDisplay(0);
                $howsay = "is now";
            }
        } else {
            printf STDERR "%s: ERROR: set xml '%s' not recognized - ignored.\n", $pkgname, $buf;
        }
        printf STDOUT "SQL/XML result-sets display %s %s\n",
            $howsay, $self->getXmlDisplay()? "ON" : "OFF";
    } else {
        printf STDERR "%s: ERROR: set '%s' not recognized - ignored.\n", $pkgname, $buf;
    }

    return 1;    #we found and processed a set command
}

sub showCreate
#generate sql to create one or all tables
#returns non-zero if error (called to process show create).
{
    my ($self, $buf) = @_;

    #get a copy of current tables object:
    my $tables = $self->getSqlTables();
    my $tbl = undef;
    my $nerrs = 0;

    #get table name if present:
    my ($tblname) = $buf;

#printf STDERR "showCreate: tblname='%s'\n", $tblname;

    #limit to one table?
    if ($tblname ne "") {
        if (!defined($tbl = $tables->tableByName($tblname))) {
            printf STDERR "%s [showCreate]:  table '%s' not found\n", $pkgname, $tblname;
            return 1;    #ERROR
        }

        #otherwise:
        return $tbl->showCreateSql();
    }

    #otherwise, get list of tables and show create for each table:
    for $tbl ($tables->allTables()) {
#printf STDERR "tbl=%s\n", $tbl;
        $tbl->showCreateSql();
    }

    return $nerrs;
}

sub showDataBase
#show database name
{
    my ($self, $buf) = @_;

    $self->sql_exec("select DATABASE()");
}

sub showIndicesCommand
#implement the show indices command, which displays the indices for a single table
#Usage:  show ind[ices] table_name
{
    my ($self, $tblname) = @_;
    my $dbname = "";

    my @excludenamesc = (
        "TABLE_CAT",
        "TABLE_SCHEM",
#       "TABLE_NAME",
#       "NON_UNIQUE",
#       "INDEX_QUALIFIER",
#       "INDEX_NAME",
        "TYPE",
#       "ORDINAL_POSITION",
#       "COLUMN_NAME",
#       "ASC_OR_DESC",
        "CARDINALITY",
        "PAGES",
        "FILTER_CONDITION"
    );

#printf STDERR "tblname='%s' dbname='%s'\n", $tblname, $dbname;

    my $dbMetaData = $self->getMetaData();
    my $rsetc = undef;

    eval {
        #########
        #Indicies
        #########
#'getIndexInfo(String catalog, String schema, String table, boolean unique, boolean approximate)'  => 'ResultSet',
        $rsetc = $dbMetaData->getIndexInfo($dbname, "%", $tblname, 0, 0);
    };

    if ($@) {
        if (caught("java.sql.SQLException")){
            my $msg = $@->getMessage() ;
            printf STDERR "%s[showTablesCommand]:  Java exception: '%s'\n", $pkgname, $msg;
        } else {
            printf STDERR "%s[showTablesCommand]:  ERROR: '%s'\n",$pkgname, $@;
        }
        return;
    }

    $self->displayResultSet($rsetc, &columnExcludeMap($rsetc, @excludenamesc));
}

sub showTableCommand
#implement the table command, which shows information about a single table
#Usage:  table table_name
{
    my ($self, $args) = @_;

    my ($tblname, $dbname) = split(/\s+/, $args);

    my @excludenames = (
        "TABLE_CAT",
        "TABLE_SCHEM",
#       "TABLE_NAME",
#       "COLUMN_NAME",
        "DATA_TYPE",
#       "TYPE_NAME",
#       "COLUMN_SIZE",
        "BUFFER_LENGTH",
        "DECIMAL_DIGITS",
        "NUM_PREC_RADIX",
#       "NULLABLE",
        "REMARKS",
        "COLUMN_DEF",
        "SQL_DATA_TYPE",
        "SQL_DATETIME_SUB",
        "CHAR_OCTET_LENGTH",
#       "ORDINAL_POSITION",
        "IS_NULLABLE",
    );

    my @excludenamesb = (
        "TABLE_CAT",
        "TABLE_SCHEM",
#       "TABLE_NAME",
#       "COLUMN_NAME",
#       "KEY_SEQ",
#       "PK_NAME",
    );

    my @excludenamesc = (
        "TABLE_CAT",
        "TABLE_SCHEM",
#       "TABLE_NAME",
#       "NON_UNIQUE",
#       "INDEX_QUALIFIER",
#       "INDEX_NAME",
        "TYPE",
#       "ORDINAL_POSITION",
#       "COLUMN_NAME",
#       "ASC_OR_DESC",
        "CARDINALITY",
        "PAGES",
        "FILTER_CONDITION"
    );

#printf STDERR "tblname='%s' dbname='%s'\n", $tblname, $dbname;

    my $dbMetaData = $self->getMetaData();
    my $rseta = undef;
    my $rsetb = undef;
    my $rsetc = undef;

    eval {
        #######
        #column info
        #######
#'getColumns(String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern)'  => 'ResultSet',
        $rseta = $dbMetaData->getColumns($dbname, "%", $tblname, "%");


#my $rseta_stmt =  $rseta->getStatement();
#printf "STATEMENT FOR getColumns() resultSet='%s'\n", defined($rseta_stmt)? "defined" : "undefined";
#my $rseta_stmt =  $rseta->getType();
#printf "TYPE FOR getColumns() resultSet='%s'\n", defined($rseta_stmt)? $rseta_stmt : "undefined" ;

        ########
        #primary keys:
        ########
#'getPrimaryKeys(String catalog, String schema, String table)'  => 'ResultSet',
        $rsetb = $dbMetaData->getPrimaryKeys($dbname, "%", $tblname);
#$rsetb_stmt =  $rsetb->getStatement();
#printf "STATEMENT FOR getPrimaryKeys()='%s'\n", $rsetb_stmt->toString();

        #########
        #Indicies
        #########
#'getIndexInfo(String catalog, String schema, String table, boolean unique, boolean approximate)'  => 'ResultSet',
        $rsetc = $dbMetaData->getIndexInfo($dbname, "%", $tblname, 0, 0);
    };

    if ($@) {
        if (caught("java.sql.SQLException")){
            my $msg = $@->getMessage() ;
            printf STDERR "%s[showTablesCommand]:  Java exception: '%s'\n", $pkgname, $msg;
        } else {
            printf STDERR "%s[showTablesCommand]:  ERROR: '%s'\n",$pkgname, $@;
        }
        return;
    }

    $self->displayResultSet($rseta, &columnExcludeMap($rseta, @excludenames ));
    $self->displayResultSet($rsetb, &columnExcludeMap($rsetb, @excludenamesb));
    $self->displayResultSet($rsetc, &columnExcludeMap($rsetc, @excludenamesc));
}

sub showTablesCommand
#implement the tables command, which shows information about tables
{
    my ($self, $dbname) = @_;
#'getTables(String catalog, String schemaPattern, String tableNamePattern, String types[])'  => 'ResultSet',
#'getSuperTables(String catalog, String schemaPattern, String tableNamePattern)'  => 'ResultSet',

    my $dbMetaData = $self->getMetaData();

    my $rseta = undef;

    my @excludenames = (
        "TABLE_CAT",
        "TABLE_SCHEM",
#       "TABLE_NAME",  #keep
        "TABLE_TYPE",
        "REMARKS",
    );

    #show the tables from the named database:
    eval {
        $rseta = $dbMetaData->getTables($dbname, "%", "%", []);
        #$rsetb = $dbMetaData->getSuperTables($dbname, "%", "%");
        #$rsetc = $dbMetaData->getSuperTypes($dbname, "%", "%");
    };

    if ($@) {
        if (caught("java.sql.SQLException")){
            my $msg = $@->getMessage() ;
            printf STDERR "%s[showTablesCommand]:  Java exception: '%s'\n", $pkgname, $msg;
        } else {
            printf STDERR "%s[showTablesCommand]:  ERROR: '%s'\n",$pkgname, $@;
        }
        return;
    }

    $self->displayResultSet($rseta, &columnExcludeMap($rseta, @excludenames));
}

sub useCommand
#change the database, get new metadata
{
    my ($self, $dbname) = @_;

    if (!defined($dbname) || $dbname eq "") {
        printf STDERR "%s: use:  you must supply a database name\n", $pkgname;
        return;
    }

    my $oldurl = $self->getJdbcUrl();

    #set connection to use new database name:
    $self->setJdbcUrl( &setDbNameInUrl($oldurl, $dbname) );

#printf STDERR "SET DATABASE TO '%s' jdbcurl='%s'\n", $dbname, $self->getJdbcUrl();

#printf STDERR "GET NEW METADATA\n";
    #get metadata for new database:
    if ($self->sql_init_connection()) {
        $self->sql_exec(sprintf("use %s;", $dbname));
    } else {
        #restore old connection url:
        $self->setJdbcUrl($oldurl);
        $self->sql_init_connection();
    }
}

sub showConnection
#show database info
{
    my ($self, $buf) = @_;
    my $func = "";

    my $metafuncs = $self->metaFuncs();

    $func = 'getURL()';
    $self->callMetaFunc($func, $$metafuncs{$func});

    $func = 'getUserName()';
    $self->callMetaFunc($func, $$metafuncs{$func});

    $func = 'getDriverName()';
    $self->callMetaFunc($func, $$metafuncs{$func});

    $func = 'getDriverVersion()';
    $self->callMetaFunc($func, $$metafuncs{$func});

    $func = 'getDatabaseProductName()';
    $self->callMetaFunc($func, $$metafuncs{$func});

    $func = 'getDatabaseProductVersion()';
    $self->callMetaFunc($func, $$metafuncs{$func});
}

sub showMetaData
#show meta-info about the database and/or tables
{
    my ($self, $buf) = @_;

    my $metafuncs = $self->metaFuncs();

    my (@noargkeys)     = grep($_ =~ /\(\)$/, sort keys %$metafuncs);
    my (@yesargkeys)    = grep($_ !~ /\(\)$/, sort keys %$metafuncs);
    my (@boolkeys)      = grep($$metafuncs{$_} eq "boolean", @noargkeys);
    my (@intkeys)       = grep($$metafuncs{$_} eq "int", @noargkeys);
    my (@strkeys)       = grep($$metafuncs{$_} eq "String", @noargkeys);
    my (@resultSetkeys) = grep($$metafuncs{$_} eq "ResultSet", @noargkeys);

    my $divider =  "-" x 56 . "\n";

    for my $kk (@boolkeys) {
        $self->callMetaFunc($kk, $$metafuncs{$kk});
    }

    print $divider;

    for my $kk (@strkeys) {
        $self->callMetaFunc($kk, $$metafuncs{$kk});
    }

    print $divider;

    for my $kk (@intkeys) {
        $self->callMetaFunc($kk, $$metafuncs{$kk});
    }

    print $divider;

    for my $kk (@resultSetkeys) {
        $self->callMetaFunc($kk, $$metafuncs{$kk});
    }

    print $divider;

#printf "yesargkeys=(%s)\n", join(",", @yesargkeys);
    for my $kk (@yesargkeys) {
        printf "%-56s %s\n", $kk, $$metafuncs{$kk};
    }
}

sub callMetaFunc
{
    my ($self, $func, $type) = @_;

    my $dbMetaData = $self->getMetaData();
    my $call = '$dbMetaData->' . "$func";

    my $val = eval($call);
    my $valstr = "$val";

    if ($type eq "boolean") {
        $valstr = ($val ? "true" : "false")
    } elsif ($type eq "int") {
        ;
    } elsif ($type eq "String") {
        ;
    } elsif ($type eq "ResultSet") {
        # dump the result:
        printf "\n%s:\n", $func;
        $self->displayResultSet($val, &columnExcludeMap($val, () ));
        return;
    } elsif ($type eq "Connection") {
        ;
    } else {
        ;
    }

    printf "%-56s %s\n", $func, $valstr;
}

#########
#accessor methods for {=PL_PACKAGE=} object attributes:
#########

{=getset_methods=}

#######
#static class methods
#######

sub columnExcludeMap
#return an array map excluding <cnames>.
#in the returned map, 0 => column not selected for display.
{
    my ($rset, @cnames) = @_;

    return () unless defined($rset);

    my (@selected) = ();

#printf STDERR "columnExcludeMap:  #cnames=%d cnames=(%s)\n", $#cnames, join(",", @cnames);

    eval {
        my $m        = $rset->getMetaData();
        my $colcnt   = $m->getColumnCount();

        #if no columns are excluded...
        if ($#cnames < 0) {
            #then return all 1's:
            @selected = ((1) x $colcnt);
#printf STDERR "columnExcludeMap:  RETURN A: selected=(%s)\n", join(",", @selected);
            return @selected;
        }

        #otherwise, exclude columns named in <cnames>:
        for (my $ii = 1; $ii <= $colcnt; $ii++) {
            my $cname = $m->getColumnLabel($ii);
#printf STDERR "columnExcludeMap: grep(%s,(%s))=%d\n", $cname, join(",", @cnames), scalar(grep($cname eq $_, @cnames));

            #exlcude  found   selected
            #      0      0          0
            #      0      1          1
            #      1      0          1
            #      1      1          0

            push @selected, (scalar(grep($cname eq $_, @cnames))? 0 : 1);
        }
    };

    if ($@) {
        if (caught("java.sql.SQLException")){
            my $msg = $@->getMessage() ;
            printf STDERR "%s[columnExcludeMap]:  Java exception: '%s'\n", $pkgname, $msg;
        } else {
            printf STDERR "%s[columnExcludeMap]:  ERROR: '%s'\n",$pkgname, $@;
        }
        return ();
    }

#printf STDERR "columnExcludeMap:  RETURN B: selected=(%s)\n", join(",", @selected);
    return @selected;
}

sub getColumns
#return the list of column names for a result set
#we only return the columns numbers in <colmap>.
{
    my ($rset, @colmap) = @_;

    return () unless defined($rset);

    my (@header) = ();
#printf STDERR "getColumns:  #colmap=%d colmap=(%s)\n", $#colmap, join(",", @colmap);

    eval {
        my $m        = $rset->getMetaData();
        my $colcnt   = $m->getColumnCount();

        #store column headers:
        for (my $ii = 1; $ii <= $colcnt; $ii++) {
            push @header, $m->getColumnLabel($ii) if ($colmap[$ii-1]);
        }
    };

    if ($@) {
        if (caught("java.sql.SQLException")){
            my $msg = $@->getMessage() ;
            printf STDERR "%s[getColumns]:  Java exception: '%s'\n", $pkgname, $msg;
        } else {
            printf STDERR "%s[getColumns]:  ERROR: '%s'\n",$pkgname, $@;
        }
        return ();
    }

    return @header;
}

sub getTableName
#return the table name of a rowset.
{
    my ($rset) = @_;

    return () unless defined($rset);

    my $tableName = "";

    eval {
        my $m        = $rset->getMetaData();
#        my $colcnt   = $m->getColumnCount();
#printf STDERR "getTableName getColumnCount()=%d\n", $colcnt;

        #this gets the table name of a particular column (1..N), so we ask for column 1:
        $tableName   = $m->getTableName(1);
    };

    if ($@) {
        if (caught("java.sql.SQLException")){
            my $msg = $@->getMessage() ;
            printf STDERR "%s[getTableName]:  Java exception: '%s'\n", $pkgname, $msg;
        } else {
            printf STDERR "%s[getTableName]:  ERROR: '%s'\n",$pkgname, $@;
        }
        return "";
    }

    return $tableName;
}

sub getColumnSizes
#return the list of column display sizes for a result set
#if <colmap> is set, then collect for the named columns.
{
    my ($rset, @colmap) = @_;

    return () unless defined($rset);

    my (@widths) = ();

    eval {
        my $m        = $rset->getMetaData();
        my $colcnt   = $m->getColumnCount();

        for (my $ii = 1; $ii <= $colcnt; $ii++) {
            push @widths, $m->getColumnDisplaySize($ii) if ($colmap[$ii-1]);
        }
    };

    if ($@) {
        if (caught("java.sql.SQLException")){
            my $msg = $@->getMessage() ;
            printf STDERR "%s[getColumnSizes]:  Java exception: '%s'\n", $pkgname, $msg;
        } else {
            printf STDERR "%s[getColumnSizes]:  ERROR: '%s'\n",$pkgname, $@;
        }
        return ();
    }

    return @widths;
}

sub getRow
#return the list of row values for the current row of <rset>.
#if <colmap> is set, then only retrieve the named columns.
{
    my ($rset, $xmldisplay, @colmap) = @_;

    return () unless defined($rset);

    my (@data) = ();

    eval {
        my $m        = $rset->getMetaData();
        my $colcnt   = $m->getColumnCount();

        for (my $ii = 1; $ii <= $colcnt; $ii++) {
            next unless ($colmap[$ii-1]);   #skip if column is not selected

            #note - you have to do the fetch first, which sets wasNull() for the current column.
            my $str = $rset->getString($ii);

            #if we are displaying xml rowsets...
            if ($xmldisplay) {
                #...then set SQL NULL elements to undef:
                push @data, ($rset->wasNull() ? undef : $str);
            } else {
                #otherwise, we will display the string "(NULL)":
                push @data, ($rset->wasNull() ? "(NULL)" : $str);
            }
        }
    };

    if ($@) {
        if (caught("java.sql.SQLException")){
            my $msg = $@->getMessage() ;
            printf STDERR "%s[getRow]:  Java exception: '%s'\n", $pkgname, $msg;
        } else {
            printf STDERR "%s[getRow]:  ERROR: '%s'\n",$pkgname, $@;
        }
        return ();
    }

    return @data;
}

sub setMaxColumnSizes
#set each element in <szref> to be max(curr, new) width for display
{
    my ($szref, $rowref) = @_;

    my @sizes = @{$szref};
    my @data =  @{$rowref};

    if ($#sizes != $#data) {
        #initialize sizes:
        @sizes = (0) x ($#data + 1);
    }

    for (my $ii = 0; $ii <= $#data; $ii++) {
        $sizes[$ii] = &maxwidth( $sizes[$ii], length(sprintf("%s", $data[$ii])) );
    }

    @{$szref} = @sizes;
}

sub maxwidth
#return the max of two numbers
{
    my ($ii, $jj) = @_;

    return (($ii >= $jj)? $ii : $jj);
}

sub getDbnameFromUrl
{
    my ($url) = @_;

    return $1 if ( $url =~ /\/([^\/]+)$/ );
    return undef;
}

sub setDbNameInUrl
{
    my ($url, $dbname) = @_;

    $url =~ s/\/([^\/]+)$//;
    return sprintf("%s/%s", $url, $dbname) if (defined($1));

    return undef;
}
EOF

%evalmacro PL_PKG_METHODS PL_PKG_METHODS
}

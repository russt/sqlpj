%include build_setup.defs

# psql.pl - prlskel program derived from template: perl/prlskel.ptpl

{
PL_USAGE := << EOF
Usage:  $pkgname [options] [file ...]

SYNOPSIS
  Creates a new database connection and runs each
  sql file provided on the command line.  If no files
  are given, then prompts for sql statements on stdin.

  Sql statements will be executed when the input contains
  a ';' command delimiter.  The delimiter must
  appear at the end of the line or alone on a line.

OPTIONS
  -help             Display this help message.
  -V                Show the $pkgname version.
  -verbose          Display additional informational messages.
  -debug            Display debug messages.
  -ddebug           Display deep debug messages.
  -quiet            Display severe errors only.

  -props file       A java property file containing the JDBC connection parameters:
                    The following property keys are recognized:

                        JDBC_CLASSPATH, JDBC_DRIVER_CLASS,
                        JDBC_URL, JDBC_USER, JDBC_PASSWORD

  -classpath string Classpath containing the JDBC driver (can be a single jar).
  -driver classname Name of the driver class
  -url name         Jdbc connection url
  -user name        Username used for connection
  -password string  Password for this user

  -e string         Execute commands from "string" and exit.  Useful for timing commands.
  -prompt string    Use <string> as prompt instead of default.
  -noprompt         Shorthand for -prompt ""

ENVIRONMENT
 CLASSPATH      Java CLASSPATH, inherited by JDBC.pm

EXAMPLES
  $pkgname -url jdbc:mysql://localhost:3306/mysql -user root -password secret -classpath mysqljdbc.jar -driver com.mysql.jdbc.Driver

  Similar example, with connection properties in "localmysql.props",
  and reading commands from "myscript.sql":

  % cat localmysql.props
JDBC_CLASSPATH=mysqljdbc.jar
JDBC_DRIVER_CLASS=com.mysql.jdbc.Driver
JDBC_URL=jdbc:mysql://localhost:3306/mysql
JDBC_USER=root
JDBC_PASSWORD=secret

  $pkgname -props localmysql.props -prompt "" myscript.sql
EOF

%evalmacro PL_USAGE PL_USAGE
}

{ ### psql defs
%ifndef PL_PACKAGE       PL_PACKAGE = $SQLPJ_PACKAGE
PL_PACKAGE_DESCRIPTION = Main driver for sqlpj - a command-line SQL interpreter for JDBC.pm

{
PL_EXTERN_PKG_IMPORTS = << EOF
use Config;
EOF
PL_PKG_IMPORTS = << EOF
use $PKGCONFIG_PACKAGE;
use $PSQLIMPL_PACKAGE;
EOF
%if    $GEN_ONE_MODULE   PL_PKG_IMPORTS = $PL_EXTERN_PKG_IMPORTS
%ifnot $GEN_ONE_MODULE   PL_PKG_IMPORTS = $PL_EXTERN_PKG_IMPORTS$PL_PKG_IMPORTS
}

PL_PKG_ATTRIBUTES := << EOF
my $USE_STDIN = 1;
my @SQLFILES = ();
my $scfg = new {=PKGCONFIG_PACKAGE=}();
#this allows signal to close/open connection:
my $psqlImpl = undef;
EOF
%evalmacro PL_PKG_ATTRIBUTES PL_PKG_ATTRIBUTES
}

{
PL_MAIN := << //

#we handle our own signals:
$SIG{'INT'}  = '{=PL_PACKAGE=}::rec_signal';
$SIG{'KILL'} = '{=PL_PACKAGE=}::rec_signal';
$SIG{'QUIT'} = '{=PL_PACKAGE=}::rec_signal';
$SIG{'TERM'} = '{=PL_PACKAGE=}::rec_signal';
$SIG{'HUP'}  = '{=PL_PACKAGE=}::rec_signal';
$SIG{'TRAP'} = '{=PL_PACKAGE=}::rec_signal';

#######
#create implementation class, passing in our configuration:
#######
$psqlImpl = new {=PSQLIMPL_PACKAGE=}($scfg);

#reset the prompt string if user supplied the option:
$psqlImpl->setPrompt($psqlImpl->userSuppliedPrompt()) if (defined($psqlImpl->userSuppliedPrompt()));

#initialize our driver class:
if (!$psqlImpl->check_driver()) {
    printf STDERR "%s:  ERROR: JDBC driver '%s' is not available for url '%s', user '%s', password '%s'\n",
        $pkgname, $psqlImpl->jdbcDriver(), $psqlImpl->getJdbcUrl(), $psqlImpl->user(), $psqlImpl->password();
    return 1;
}

if ( $psqlImpl->getExecCommandString() ) {
    #...if we have an immediate command to execute, then do it and exit:
    if (!$psqlImpl->sql_init_connection()) {
        printf STDERR "%s:[sqlsession]:  cannot get a database connection:  ABORT\n", $pkgname;
        return 1;
    } else {
       #return zero status if sql_exec is successful:
       return !( $psqlImpl->sql_exec($psqlImpl->getExecCommandString()) );
    }
} elsif ($USE_STDIN) {
#printf STDERR "%s:  using stdin\n", $pkgname;
    my $stdinh = "STDIN";
    $psqlImpl->sqlsession($stdinh, "<STDIN>");
} else {
    my $infile;
    for (my $ii = 0; $ii <= $#SQLFILES; $ii++) {
        if (open($infile, $SQLFILES[$ii])) {
            $psqlImpl->sqlsession($infile, $SQLFILES[$ii]);
            close $infile;
        } else {
            printf STDERR "%s:  ERROR: cannot open sql input, '%s':  '%s'\n", $pkgname, $SQLFILES[$ii], $!;
        }
    }
}
//
%evalmacro PL_MAIN PL_MAIN
}

{ #subroutines
PL_PKG_METHODS := << //
sub checkSetClasspath
#if we have a classpath setting, then add to the environemnt.
#
#NOTE:  inline java will ignore any new CLASSPATH setting after
#       the module is loaded.  A work-around is to use "require" to load it.
{
    my ($cfg) = @_;

#printf STDERR "BEFORE CLASSPATH='%s'\n", $ENV{'CLASSPATH'};
    if (defined($cfg->getJdbcClassPath())) {
        if (defined($ENV{'CLASSPATH'}) && $ENV{'CLASSPATH'} ne "") {
            $ENV{'CLASSPATH'} = sprintf("%s%s%s", $cfg->getJdbcClassPath(), $cfg->getPathSeparator(), $ENV{'CLASSPATH'});
        } else {
            $ENV{'CLASSPATH'} = $cfg->getJdbcClassPath();
        }
    }
#printf STDERR "AFTER CLASSPATH='%s'\n", $ENV{'CLASSPATH'};
}

sub checkJdbcSettings
#return true(1) if jdbc properties are all defined.
{
    my ($cfg) = @_;
    my $errs = 0;

    if (!defined($cfg->getJdbcDriverClass())) {
        ++$errs; printf STDERR "%s:  missing JDBC driver class\n", $p;
    }
    if (!defined($cfg->getJdbcUrl())) {
        ++$errs; printf STDERR "%s:  missing JDBC URL\n", $p
    }
    if (!defined($cfg->getJdbcUser())) {
        ++$errs; printf STDERR "%s:  missing JDBC User name\n", $p;
    }
    if (!defined($cfg->getJdbcPassword())) {
        ++$errs; printf STDERR "%s:  missing JDBC User password\n", $p;
    }

    return($errs == 0);
}

sub rec_signal
# we only want to abort sqlexec in progress, not program.
{
    local($SIG) = @_;
    my($prevHandler) = $SIG{$SIG};

    # Reestablish the handler.
    $SIG{$SIG} = $prevHandler;
    printf STDERR ("\n%s:  Received SIG%s%s\n", $p, $SIG, ($SIG eq "HUP")? " - IGNORED" : "");

#printf STDERR "psqlImpl=%s connection=%s\n", ref($psqlImpl), ref($psqlImpl->getConnection());

    #reinitialize the connection if we got that far:
    if ($psqlImpl->getConnection()) {
        #none of this works...don't know how to recover the JVM or SQL connections.  RT 2/8/13
        #Inline::Java->reconnect_JVM();
        #JDBC->load_driver($psqlImpl->jdbcDriver());
        #$psqlImpl->sql_init_connection() 
    } else {
        #if we have not initialized Inline::Java, then we can safetly continue.
        return;
    }

    main::abort("Shutting down.\n");
}
//
}

{
PL_PARSE_ARGS_PRE := << EOF
#set defaults:
$scfg->setProgName($p);
$scfg->setPathSeparator($Config{path_sep});
EOF
%evalmacro PL_PARSE_ARGS_PRE PL_PARSE_ARGS_PRE

{
{ #balance braces
PL_PARSE_ARGS_LOOP := << EOF
} elsif ($flag =~ '^-V') {
    # -V                show version and exit
    printf STDOUT "%s, Version %s, %s.\n",
        $scfg->getProgName(), $scfg->versionNumber(), $scfg->versionDate();
    $HELPFLAG = 1;    #display version and exit.
    return 0;
} elsif ($flag =~ '^-q') {
    $QUIET = 1;
} elsif ($flag =~ '^-user') {
    # -user name        Username used for connection
    if ($#ARGV+1 > 0 && $ARGV[0] !~ /^-/) {
        $scfg->setJdbcUser(shift(@ARGV));
    } else {
        printf STDERR "%s:  -user requires user name.\n", $p;
        return 1;
    }
} elsif ($flag =~ '^-pass') {
    # -password string  Password for this user
    if ($#ARGV+1 > 0 && $ARGV[0] !~ /^-/) {
        $scfg->setJdbcPassword(shift(@ARGV));
    } else {
        printf STDERR "%s:  -password requires password string.\n", $p;
        return 1;
    }
} elsif ($flag =~ '^-e') {
    # -e string  Execute commands from "string" and exit.
    if ($#ARGV+1 > 0 && $ARGV[0] !~ /^-/) {
        $scfg->setExecCommandString(shift(@ARGV));
    } else {
        printf STDERR "%s:  -e requires string containing commands.\n", $p;
        return 1;
    }
} elsif ($flag =~ '^-driver') {
    # -driver classname Name of the driver class
    if ($#ARGV+1 > 0 && $ARGV[0] !~ /^-/) {
        $scfg->setJdbcDriverClass(shift(@ARGV));
    } else {
        printf STDERR "%s:  -driver requires driver class name.\n", $p;
        return 1;
    }
} elsif ($flag =~ '^-classpath') {
    # -classpath string Classpath containing the JDBC driver (can be a single jar).
    if ($#ARGV+1 > 0 && $ARGV[0] !~ /^-/) {
        $scfg->setJdbcClassPath(shift(@ARGV));
    } else {
        printf STDERR "%s:  -classpath requires classpath setting.\n", $p;
        return 1;
    }
} elsif ($flag =~ '^-props') {
    # -props <file>        Set JDBC connection properties from <file>
    if ($#ARGV+1 > 0 && $ARGV[0] !~ /^-/) {
        $scfg->setJdbcPropsFileName(shift(@ARGV));
        #parse the properties file - additional command line args can override:
        $scfg->parseJdbcPropertiesFile();
    } else {
        printf STDERR "%s:  -props requires a file name containing JDBC connection properties.\n", $p;
        return 1;
    }
} elsif ($flag =~ '^-url') {
    # -url name         Jdbc connection url
    if ($#ARGV+1 > 0 && $ARGV[0] !~ /^-/) {
        $scfg->setJdbcUrl(shift(@ARGV));
    } else {
        printf STDERR "%s:  -url requires the JDBC connection url\n", $p;
        return 1;
    }
} elsif ($flag =~ '^-noprompt') {
    # clear prompt, same as "-prompt ''"
    $scfg->setUserSuppliedPrompt('');
} elsif ($flag =~ '^-prompt') {
    # -prompt string    Use <string> as prompt instead of default.
    if ($#ARGV+1 > 0 && $ARGV[0] !~ /^-/) {
        $scfg->setUserSuppliedPrompt(shift(@ARGV));
    } else {
        printf STDERR "%s:  -prompt requires the prompt string.\n", $p;
        return 1;
    }
EOF
} #balance braces
} #end of parse arg loop defs

PL_PARSE_ARGS_POST := << EOF
#set debug, verbose options:
$scfg->setDebug($DEBUGFLAG);
$scfg->setDDebug($DDEBUGFLAG);
$scfg->setQuiet($QUIET);
$scfg->setVerbose($VERBOSE);

#check the JDBC configuration:
if (!&checkJdbcSettings($scfg)) {
    printf STDERR "%s:  one or more JDBC connection settings are missing or incomplete - ABORT.\n", $p;
    return 1;
}

#add to the CLASSPATH if required:
&checkSetClasspath($scfg);

#do we have file args?
#take remaining args as directories to walk:
if ($#ARGV >= 0) {
    @SQLFILES = @ARGV;
    $USE_STDIN = 0;
}
EOF
} #end of parse arg defs

